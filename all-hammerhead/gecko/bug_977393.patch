diff --git a/gfx/layers/ipc/FenceUtilsGonk.cpp b/gfx/layers/ipc/FenceUtilsGonk.cpp
index cd87465..1bbf081 100644
--- a/gfx/layers/ipc/FenceUtilsGonk.cpp
+++ b/gfx/layers/ipc/FenceUtilsGonk.cpp
@@ -16,24 +16,43 @@ using namespace base;
 using namespace mozilla::layers;
 
 namespace IPC {
 
 void
 ParamTraits<FenceHandle>::Write(Message* aMsg,
                                 const paramType& aParam)
 {
+#if ANDROID_VERSION >= 19
+  sp<Fence> flattenable = aParam.mFence;
+#else
   Flattenable *flattenable = aParam.mFence.get();
+#endif
   size_t nbytes = flattenable->getFlattenedSize();
   size_t nfds = flattenable->getFdCount();
 
   char data[nbytes];
   int fds[nfds];
-  flattenable->flatten(data, nbytes, fds, nfds);
 
+#if ANDROID_VERSION >= 19
+  // Make a copy of "data" and "fds" for flatten() to avoid casting problem
+  void *pdata = (void *)data;
+  int *pfds = fds;
+
+  flattenable->flatten(pdata, nbytes, pfds, nfds);
+
+  // In Kitkat, flatten() will change the value of nbytes and nfds, which dues
+  // to multiple parcelable object consumption. The actual size and fd count
+  // which returned by getFlattenedSize() and getFdCount() are not changed.
+  // So we change nbytes and nfds back by call corresponding calls.
+  nbytes = flattenable->getFlattenedSize();
+  nfds = flattenable->getFdCount();
+#else
+  flattenable->flatten(data, nbytes, fds, nfds);
+#endif
   aMsg->WriteSize(nbytes);
   aMsg->WriteSize(nfds);
 
   aMsg->WriteBytes(data, nbytes);
   for (size_t n = 0; n < nfds; ++n) {
     // These buffers can't die in transit because they're created
     // synchonously and the parent-side buffer can only be dropped if
     // there's a crash.
@@ -68,19 +87,27 @@ ParamTraits<FenceHandle>::Read(const Message* aMsg,
     // deal with it here.  NB: only the "default" (master) process can
     // alloc gralloc buffers.
     bool sameProcess = (XRE_GetProcessType() == GeckoProcessType_Default);
     int dupFd = sameProcess ? dup(fd.fd) : fd.fd;
     fds[n] = dupFd;
   }
 
   sp<Fence> buffer(new Fence());
+#if ANDROID_VERSION >= 19
+  // Make a copy of "data" and "fds" for unflatten() to avoid casting problem
+  void const *pdata = (void const *)data;
+  int const *pfds = fds;
+
+  if (NO_ERROR == buffer->unflatten(pdata, nbytes, pfds, nfds)) {
+#else
   Flattenable *flattenable = buffer.get();
 
   if (NO_ERROR == flattenable->unflatten(data, nbytes, fds, nfds)) {
+#endif
     aResult->mFence = buffer;
     return true;
   }
   return false;
 }
 
 } // namespace IPC
 
diff --git a/gfx/layers/moz.build b/gfx/layers/moz.build
index 6af87fd..67f6822 100644
--- a/gfx/layers/moz.build
+++ b/gfx/layers/moz.build
@@ -198,17 +198,17 @@ if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'gonk':
         'opengl/EGLImageHelpers.cpp',
         'opengl/GrallocTextureClient.cpp',
         'opengl/GrallocTextureHost.cpp',
     ]
     SOURCES += [
         'ipc/ShadowLayerUtilsGralloc.cpp',
     ]
 
-    if CONFIG['ANDROID_VERSION'] in ('18'):
+    if CONFIG['ANDROID_VERSION'] >= '18':
         EXPORTS.mozilla.layers += [
             'ipc/FenceUtilsGonk.h',
         ]
         SOURCES += [
             'ipc/FenceUtilsGonk.cpp',
         ]
 
 UNIFIED_SOURCES += [
