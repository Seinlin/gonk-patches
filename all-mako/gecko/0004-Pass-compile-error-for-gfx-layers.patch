From 916e1414f6a1ff76c8442f031bcff68b6c744692 Mon Sep 17 00:00:00 2001
From: Kai-Zhen Li <kli@mozilla.com>
Date: Mon, 16 Dec 2013 17:47:12 +0800
Subject: [PATCH] Pass compile error for gfx

---
 gfx/layers/ipc/ShadowLayerUtilsGralloc.cpp       |   27 +++++++++---
 widget/gonk/libdisplay/FramebufferSurface.cpp    |   50 ++++++++++++++++++++++
 widget/gonk/libdisplay/FramebufferSurface.h      |   17 ++++++++
 widget/gonk/libdisplay/GonkDisplayJB.cpp         |   12 +++++-
 widget/gonk/libdisplay/moz.build                 |    2 +-
 widget/gonk/libui/EventHub.cpp                   |    3 +-
 widget/gonk/libui/cutils_log.h                   |   26 +++++++----
 widget/gonk/nativewindow/FakeSurfaceComposer.cpp |   11 +++++
 8 files changed, 129 insertions(+), 19 deletions(-)

diff --git a/gfx/layers/ipc/ShadowLayerUtilsGralloc.cpp b/gfx/layers/ipc/ShadowLayerUtilsGralloc.cpp
index bfc85c1..4d53ce9c 100644
--- a/gfx/layers/ipc/ShadowLayerUtilsGralloc.cpp
+++ b/gfx/layers/ipc/ShadowLayerUtilsGralloc.cpp
@@ -42,18 +42,28 @@ void
 ParamTraits<MagicGrallocBufferHandle>::Write(Message* aMsg,
                                              const paramType& aParam)
 {
-  Flattenable *flattenable = aParam.mGraphicBuffer.get();
-  size_t nbytes = flattenable->getFlattenedSize();
-  size_t nfds = flattenable->getFdCount();
+  sp<GraphicBuffer> buffer = aParam.mGraphicBuffer;
+
+  size_t nbytes = buffer->getFlattenedSize();
+  size_t nfds = buffer->getFdCount();
 
   char data[nbytes];
   int fds[nfds];
-  flattenable->flatten(data, nbytes, fds, nfds);
+  // Make a copy of "data" and "fds" for flatten() to avoid casting problem
+  void *pdata = (void *)data;
+  int *pfds = fds;
+
+  buffer->flatten(pdata, nbytes, pfds, nfds);
+
+  // In Kitkat, flatten() will change the value of nbytes and nfds.
+  // need to change them back.
+  nbytes = buffer->getFlattenedSize();
+  nfds = buffer->getFdCount();
 
   aMsg->WriteSize(nbytes);
   aMsg->WriteSize(nfds);
-
   aMsg->WriteBytes(data, nbytes);
+
   for (size_t n = 0; n < nfds; ++n) {
     // These buffers can't die in transit because they're created
     // synchonously and the parent-side buffer can only be dropped if
@@ -94,9 +104,12 @@ ParamTraits<MagicGrallocBufferHandle>::Read(const Message* aMsg,
   }
 
   sp<GraphicBuffer> buffer(new GraphicBuffer());
-  Flattenable *flattenable = buffer.get();
 
-  if (NO_ERROR == flattenable->unflatten(data, nbytes, fds, nfds)) {
+  // Make a copy of "data" and "fds" for unflatten() to avoid casting problem
+  void const *pdata = (void const *)data;
+  int const *pfds = fds;
+
+  if (NO_ERROR == buffer->unflatten(pdata, nbytes, pfds, nfds)) {
     aResult->mGraphicBuffer = buffer;
     return true;
   }
diff --git a/widget/gonk/libdisplay/FramebufferSurface.cpp b/widget/gonk/libdisplay/FramebufferSurface.cpp
index 99dbfbb..985fdbd 100644
--- a/widget/gonk/libdisplay/FramebufferSurface.cpp
+++ b/widget/gonk/libdisplay/FramebufferSurface.cpp
@@ -50,6 +50,25 @@ namespace android {
  * was adapted from the version in SurfaceFlinger
  */
 
+#if ANDROID_VERSION == 19
+FramebufferSurface::FramebufferSurface(int disp, uint32_t width, uint32_t height, uint32_t format,
+        const sp<IGraphicBufferConsumer>& consumer) :
+    ConsumerBase(consumer, true),
+    mDisplayType(disp),
+    mCurrentBufferSlot(-1),
+    mCurrentBuffer(0),
+    lastHandle(0)
+{
+    mName = "FramebufferSurface";
+    mConsumer->setConsumerName(mName);
+    mConsumer->setConsumerUsageBits(GRALLOC_USAGE_HW_FB |
+                                       GRALLOC_USAGE_HW_RENDER |
+                                       GRALLOC_USAGE_HW_COMPOSER);
+    mConsumer->setDefaultBufferFormat(format);
+    mConsumer->setDefaultBufferSize(width,  height);
+    mConsumer->setDefaultMaxBufferCount(NUM_FRAMEBUFFER_SURFACE_BUFFERS);
+}
+#else
 FramebufferSurface::FramebufferSurface(int disp, uint32_t width, uint32_t height, uint32_t format, sp<IGraphicBufferAlloc>& alloc) :
     ConsumerBase(new BufferQueue(true, alloc)),
     mDisplayType(disp),
@@ -67,12 +86,17 @@ FramebufferSurface::FramebufferSurface(int disp, uint32_t width, uint32_t height
     mBufferQueue->setSynchronousMode(true);
     mBufferQueue->setDefaultMaxBufferCount(NUM_FRAMEBUFFER_SURFACE_BUFFERS);
 }
+#endif
 
 status_t FramebufferSurface::nextBuffer(sp<GraphicBuffer>& outBuffer, sp<Fence>& outFence) {
     Mutex::Autolock lock(mMutex);
 
     BufferQueue::BufferItem item;
+#if ANDROID_VERSION == 19
+    status_t err = acquireBufferLocked(&item, 0);
+#else
     status_t err = acquireBufferLocked(&item);
+#endif
     if (err == BufferQueue::NO_BUFFER_AVAILABLE) {
         outBuffer = mCurrentBuffer;
         return NO_ERROR;
@@ -92,8 +116,13 @@ status_t FramebufferSurface::nextBuffer(sp<GraphicBuffer>& outBuffer, sp<Fence>&
     if (mCurrentBufferSlot != BufferQueue::INVALID_BUFFER_SLOT &&
         item.mBuf != mCurrentBufferSlot) {
         // Release the previous buffer.
+#if ANDROID_VERSION == 19
+        err = releaseBufferLocked(mCurrentBufferSlot, mCurrentBuffer,
+                EGL_NO_DISPLAY, EGL_NO_SYNC_KHR);
+#else
         err = releaseBufferLocked(mCurrentBufferSlot, EGL_NO_DISPLAY,
                 EGL_NO_SYNC_KHR);
+#endif
         if (err != NO_ERROR && err != BufferQueue::STALE_BUFFER_SLOT) {
             ALOGE("error releasing buffer: %s (%d)", strerror(-err), err);
             return err;
@@ -136,7 +165,11 @@ status_t FramebufferSurface::setReleaseFenceFd(int fenceFd) {
     if (fenceFd >= 0) {
         sp<Fence> fence(new Fence(fenceFd));
         if (mCurrentBufferSlot != BufferQueue::INVALID_BUFFER_SLOT) {
+#if ANDROID_VERSION == 19
+            status_t err = addReleaseFence(mCurrentBufferSlot, mCurrentBuffer,  fence);
+#else
             status_t err = addReleaseFence(mCurrentBufferSlot, fence);
+#endif
             ALOGE_IF(err, "setReleaseFenceFd: failed to add the fence: %s (%d)",
                     strerror(-err), err);
         }
@@ -157,6 +190,23 @@ status_t FramebufferSurface::compositionComplete()
 void FramebufferSurface::dump(String8& result) {
     ConsumerBase::dump(result);
 }
+// Todo kitkat
+void FramebufferSurface::dump(String8& result, const char* prefix) {
+    ConsumerBase::dump(result);
+}
+
+#if 1
+sp<IGraphicBufferConsumer> FramebufferSurface::getBufferQueue() {
+    Mutex::Autolock lock(mMutex);
+    return mConsumer;
+}
+#else
+sp<BufferQueue> FramebufferSurface::getBufferQueue() {
+    Mutex::Autolock lock(mMutex);
+    return static_cast< sp<BufferQueue> >(mConsumer);
+}
+#endif
+
 
 // ----------------------------------------------------------------------------
 }; // namespace android
diff --git a/widget/gonk/libdisplay/FramebufferSurface.h b/widget/gonk/libdisplay/FramebufferSurface.h
index 38db795..a2c469c 100644
--- a/widget/gonk/libdisplay/FramebufferSurface.h
+++ b/widget/gonk/libdisplay/FramebufferSurface.h
@@ -34,13 +34,21 @@ class HWComposer;
 
 class FramebufferSurface : public ConsumerBase {
 public:
+// Todo kitkat
+#if ANDROID_VERSION == 19
+    FramebufferSurface(int disp, uint32_t width, uint32_t height, uint32_t format,
+	const sp<IGraphicBufferConsumer>& consumer);
+#else
     FramebufferSurface(int disp, uint32_t width, uint32_t height, uint32_t format, sp<IGraphicBufferAlloc>& alloc);
+#endif
 
     bool isUpdateOnDemand() const { return false; }
     status_t setUpdateRectangle(const Rect& updateRect);
     status_t compositionComplete();
 
     virtual void dump(String8& result);
+    // Todo kitkat
+    virtual void dump(String8& result, const char* prefix);
 
     // setReleaseFenceFd stores a fence file descriptor that will signal when the
     // current buffer is no longer being read. This fence will be returned to
@@ -50,6 +58,15 @@ public:
     // when finished with it.
     status_t setReleaseFenceFd(int fenceFd);
 
+    // copied from ConsumerBase of JB43
+    // getBufferQueue returns the BufferQueue object to which this
+    // ConsumerBase is connected.
+#if 1
+    sp<IGraphicBufferConsumer> getBufferQueue();
+#else
+    sp<BufferQueue> getBufferQueue();
+#endif
+
     buffer_handle_t lastHandle;
     int lastFenceFD;
 private:
diff --git a/widget/gonk/libdisplay/GonkDisplayJB.cpp b/widget/gonk/libdisplay/GonkDisplayJB.cpp
index 7ab251a..9c984e2 100644
--- a/widget/gonk/libdisplay/GonkDisplayJB.cpp
+++ b/widget/gonk/libdisplay/GonkDisplayJB.cpp
@@ -114,13 +114,23 @@ GonkDisplayJB::GonkDisplayJB()
         mBootAnimBuffer = mAlloc->createGraphicBuffer(mWidth, mHeight, surfaceformat, usage, &error);
     }
 
-    mFBSurface = new FramebufferSurface(0, mWidth, mHeight, surfaceformat, mAlloc);
+    // Todo kitkat
+    //mFBSurface = new FramebufferSurface(0, disp, consumer); //0, mWidth, mHeight, surfaceformat, mAlloc);
+    sp<BufferQueue> bq = new BufferQueue(mAlloc);
+    mFBSurface = new FramebufferSurface(0, mWidth, mHeight, surfaceformat, bq);
 
 #if ANDROID_VERSION == 17
     sp<SurfaceTextureClient> stc = new SurfaceTextureClient(static_cast<sp<ISurfaceTexture> >(mFBSurface->getBufferQueue()));
 #else
+    // Todo kitkat
+
+#if ANDROID_VERSION == 19
+    sp<Surface> stc = new Surface(static_cast<sp<IGraphicBufferProducer> >(bq));
+#else
     sp<Surface> stc = new Surface(static_cast<sp<IGraphicBufferProducer> >(mFBSurface->getBufferQueue()));
 #endif
+
+#endif
     mSTClient = stc;
 
     mList = (hwc_display_contents_1_t *)malloc(sizeof(*mList) + (sizeof(hwc_layer_1_t)*2));
diff --git a/widget/gonk/libdisplay/moz.build b/widget/gonk/libdisplay/moz.build
index 6690227..9648664 100644
--- a/widget/gonk/libdisplay/moz.build
+++ b/widget/gonk/libdisplay/moz.build
@@ -18,7 +18,7 @@ SOURCES += [
     'BootAnimation.cpp',
 ]
 
-if CONFIG['ANDROID_VERSION'] >= '18':
+if CONFIG['ANDROID_VERSION'] in ('18', '19'):
     SOURCES += [
         'FramebufferSurface.cpp',
         'GonkDisplayJB.cpp',
diff --git a/widget/gonk/libui/EventHub.cpp b/widget/gonk/libui/EventHub.cpp
index 89581bc..4680d86 100644
--- a/widget/gonk/libui/EventHub.cpp
+++ b/widget/gonk/libui/EventHub.cpp
@@ -49,7 +49,8 @@
 #include <sys/epoll.h>
 #include <sys/ioctl.h>
 #include <sys/limits.h>
-#include <sha1.h>
+//#include <sha1.h>
+#include <sys/sha1.h>
 
 /* this macro is used to tell if "bit" is set in "array"
  * it selects a byte from the array, and does a boolean AND
diff --git a/widget/gonk/libui/cutils_log.h b/widget/gonk/libui/cutils_log.h
index 8b045c7..aa65c90 100644
--- a/widget/gonk/libui/cutils_log.h
+++ b/widget/gonk/libui/cutils_log.h
@@ -37,8 +37,14 @@
 #endif
 #include <stdarg.h>
 
+// Todo kitkat
+#if 1
+#include <log/uio.h>
+#include <log/logd.h>
+#else
 #include <cutils/uio.h>
 #include <cutils/logd.h>
+#endif
 
 #ifdef __cplusplus
 extern "C" {
@@ -460,6 +466,7 @@ extern "C" {
  * Event logging.
  */
 
+#if 0 // Todo kitkat
 /*
  * Event log entry types.  These must match up with the declarations in
  * java/android/android/util/EventLog.java.
@@ -471,6 +478,16 @@ typedef enum {
     EVENT_TYPE_LIST     = 3,
 } AndroidEventLogType;
 
+typedef enum {
+    LOG_ID_MAIN = 0,
+    LOG_ID_RADIO = 1,
+    LOG_ID_EVENTS = 2,
+    LOG_ID_SYSTEM = 3,
+
+    LOG_ID_MAX
+} log_id_t;
+
+#endif
 
 #ifndef LOG_EVENT_INT
 #define LOG_EVENT_INT(_tag, _value) {                                       \
@@ -540,15 +557,6 @@ typedef enum {
 #define android_logToFile(tag, file) (0)
 #define android_logToFd(tag, fd) (0)
 
-typedef enum {
-    LOG_ID_MAIN = 0,
-    LOG_ID_RADIO = 1,
-    LOG_ID_EVENTS = 2,
-    LOG_ID_SYSTEM = 3,
-
-    LOG_ID_MAX
-} log_id_t;
-
 /*
  * Send a simple string to the log.
  */
diff --git a/widget/gonk/nativewindow/FakeSurfaceComposer.cpp b/widget/gonk/nativewindow/FakeSurfaceComposer.cpp
index fddd6b9..ef63681 100644
--- a/widget/gonk/nativewindow/FakeSurfaceComposer.cpp
+++ b/widget/gonk/nativewindow/FakeSurfaceComposer.cpp
@@ -59,6 +59,10 @@ sp<IBinder> FakeSurfaceComposer::createDisplay(const String8& displayName,
     return nullptr;
 }
 
+void FakeSurfaceComposer::destroyDisplay(const sp<IBinder>& display)
+{
+}
+
 sp<IBinder> FakeSurfaceComposer::getBuiltInDisplay(int32_t id) {
     return nullptr;
 }
@@ -91,6 +95,13 @@ status_t FakeSurfaceComposer::captureScreen(const sp<IBinder>& display,
     return INVALID_OPERATION;
 }
 
+status_t FakeSurfaceComposer::captureScreen(const sp<IBinder>& display, 
+    const sp<IGraphicBufferProducer>& producer,
+    uint32_t reqWidth, uint32_t reqHeight,
+    uint32_t minLayerZ, uint32_t maxLayerZ) {
+    return INVALID_OPERATION;
+}
+
 void FakeSurfaceComposer::blank(const sp<IBinder>& display) {
 }
 
-- 
1.7.9.5

